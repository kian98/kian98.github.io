<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Leetcode-剑指Offer-Log-1 - bbbbbbb log</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="刷题刷题！目前第6天" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Leetcode-剑指Offer-Log-1" />
<meta property="og:description" content="刷题刷题！目前第6天" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kian98.github.io/posts/leetcode_log_0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-27T16:53:00+08:00" />
<meta property="article:modified_time" content="2021-11-27T16:53:00+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode-剑指Offer-Log-1"/>
<meta name="twitter:description" content="刷题刷题！目前第6天"/>
<script src="https://kian98.github.io/js/feather.min.js"></script>
	
	
        <link href="https://kian98.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://kian98.github.io/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://kian98.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://kian98.github.io/">bbbbbbb log</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Leetcode-剑指Offer-Log-1</h1>
			<div class="meta">Posted on Nov 27, 2021</div>
		</div>
		

		<section class="body">
			<h2 id="day-1-栈与队列--easy-">Day 1. 栈与队列 ( Easy )</h2>
<h3 id="剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</h3>
<p>栈的特点是后进后出，队列是先进后出。使用双栈相当于使用其中一个栈作为暂存的区域，来实现队列的功能。</p>
<h3 id="剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</h3>
<p>题目要求：实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>考虑栈后入先出的特点，解题思路是，在入栈时，每个元素添加一个额外属性：当前最小值。</p>
<h2 id="day-2-链表--easy-">Day 2. 链表 ( Easy )</h2>
<h3 id="剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</h3>
<p>两种思路：</p>
<p><strong>辅助栈</strong>。利用栈后进先出的特性，额外开辟一个栈暂存链表数据，出栈时即为逆序。</p>
<p><strong>递归</strong>。利用递归，先走到链表结尾，回溯时依次将值加入到队列中。</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> reversePrint(ListNode<span style="color:#f92672">*</span> head){
  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>head) <span style="color:#66d9ef">return</span> {};
  <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>val;
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ret <span style="color:#f92672">=</span> reversePrint(head<span style="color:#f92672">-&gt;</span>next);
  ret.push_back(val);
  <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p><strong>粗暴法</strong>。顺序保存，用algorithm库直接reverse。</p>
<h3 id="剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</h3>
<p>数据结构入门题目。三种基本解法。</p>
<p><strong>迭代法</strong>。使用<strong>双指针</strong>。设置一个cur指针指示当前所在位置，一个pre指针指向前一个节点。</p>
<p>初始状态下，cur指向的是head节点，pre指向NULL。</p>
<p>迭代过程中，先暂存cur-&gt;next所指向的节点为temp，将cur-&gt;next指向pre，再将pre更新为cur，cur更新为temp，完成翻转。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">reverseList</span>(ListNode<span style="color:#f92672">*</span> head) {
  ListNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> NULL;
  ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> head;
  <span style="color:#66d9ef">while</span>(cur){
    ListNode<span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
    cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre;
    pre <span style="color:#f92672">=</span> cur;
    cur <span style="color:#f92672">=</span> next;
  }
  <span style="color:#66d9ef">return</span> pre;
}
</code></pre></div><p><strong>辅助栈法</strong>。先遍历链表，保存value到栈中，再依次出栈，重新为链表赋值。</p>
<p><strong>递归法</strong>。核心思想是，对于当前节点cur，将下一个节点cu r-&gt;next为头节点的链表进行翻转，然后将cur-&gt;next节点的next指针指向cur，完成翻转。</p>
<p>需要注意三个情况，（1）输入为NULL时，直接返回head（2）处理head节点时，head-&gt;next在反转后最后应该为NULL（3）最后需要返回反转后的新的头节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">reverseList</span>(ListNode<span style="color:#f92672">*</span> head) {
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>head <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>head<span style="color:#f92672">-&gt;</span>next ) <span style="color:#66d9ef">return</span> head;
    ListNode<span style="color:#f92672">*</span> newHead <span style="color:#f92672">=</span> reverseList(head<span style="color:#f92672">-&gt;</span>next);
    head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> newHead;
}
</code></pre></div><h3 id="剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</h3>
<p>该题关键在于如何记录原链表和新链表的节点对应关系。直观解法是使用哈希，即Map。</p>
<p><strong>哈希表法</strong>。空间复杂度为O(n)，时间复杂度为O(n)，遍历两遍原链表。</p>
<p><strong>原地复制</strong>。首先将每个节点复制一遍，添加到原有节点之后，如1-&gt;2-&gt;3-&gt;NULL复制为1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;NULL；从头开始遍历链表，将random指针指向对应节点或NULL；将链表拆分。该方法可以将空间复杂度降低为O(1)。</p>
<h2 id="day-3-字符串--easy-">Day 3. 字符串 ( Easy )</h2>
<h3 id="剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</h3>
<p>使用string API操作，可以使用find、erase、insert原地操作；也可以遍历操作，新建字符串，使用append。</p>
<p>一定要用时间复杂度为O(n)。</p>
<p>可以使用双指针，用vector。</p>
<p>可以使用array数组，第一遍遍历确定空格数量，确定新数组的长度，第二遍遍历就可以直接复制给新数组。</p>
<p>从前往后遍历替换会导致元素被覆盖，则<strong>可以考虑从后往前遍历。</strong></p>
<h3 id="剑指-offer-58---ii-左旋转字符串">剑指 Offer 58 - II. 左旋转字符串</h3>
<p>使用string API操作，则使用substr获取子串。</p>
<p><strong>原地反转</strong>。思路是先反转n以前的子串，再反转n以后的子串，最后反转整个子串，可以得到一个拼接后的子串。问题化简为三个字符串反转问题。</p>
<p>原地字符串反转，使用双指针解法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> reverseString(string <span style="color:#f92672">&amp;</span>s, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j){
        <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;</span> j){
            s[i] <span style="color:#f92672">^=</span> s[j];
            s[j] <span style="color:#f92672">^=</span> s[i];
            s[i] <span style="color:#f92672">^=</span> s[j];
            i<span style="color:#f92672">++</span>;j<span style="color:#f92672">--</span>;
        }
    }
    string <span style="color:#a6e22e">reverseLeftWords</span>(string s, <span style="color:#66d9ef">int</span> n) {
        reverseString(s, <span style="color:#ae81ff">0</span>, n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        reverseString(s, n, s.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        reverseString(s, <span style="color:#ae81ff">0</span>, s.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">return</span> s;
    }
};
</code></pre></div><h2 id="day-4-查找算法---easy-">Day 4. 查找算法  ( Easy )</h2>
<h3 id="剑指-offer-03-数组中重复的数字">剑指 Offer 03. 数组中重复的数字</h3>
<p>最直接思路是利用<strong>哈希表</strong>，C++中使用map。时间复杂度O(n)，空间复杂度也为O(n)。</p>
<p><strong>排序后遍历</strong>。先原地排序（如堆排序），若相邻元素相同，则return。</p>
<p><strong>原地交换</strong>。题干中指明，所有数字都在 0～n-1 的范围内，数组索引和值是一对多的关系，因此可以通过交换值，使得数组的索引和值达到对应。即</p>
<p>若nums[i] = i，则继续下一个i；</p>
<p>若nums[i] = nums[nums[i]]，说明有两个索引指向同一个值，找到该值；</p>
<p>否则交换nums[i]和nums[nums[i]]的值，这一步的最终必然可以将值换到与索引匹配的位置，或者找到重复值。</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)。</p>
<h3 id="剑指-offer-53---i-在排序数组中查找数字-i">剑指 Offer 53 - I. 在排序数组中查找数字 I</h3>
<p>在有序数组中查找数字出现次数，明显可以用<strong>二分查找法</strong>。</p>
<p>可以通过二分查找找到第一个出现的数字，也可以直接使用二分查找确定左右范围。</p>
<h3 id="剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</h3>
<p>同样使用<strong>二分查找</strong>。需要注意，二分查找要点在于边界值判断、循环条件判断，并且两者需要匹配。例如，left和right值如果存在不更新，直接等于mid的情况，那么while条件需要设置为不包括left=right。</p>
<h2 id="day-5-查找算法-medium">Day 5. 查找算法 (Medium)</h2>
<h3 id="-剑指-offer-04-二维数组中的查找">⭐️ 剑指 Offer 04. 二维数组中的查找</h3>
<p>一开始以为要用二分查找，但发现并不适用，并且会超时。</p>
<p>参考评论后，可以从矩阵右上角开始看，可以发现矩阵分布规律，类似一个<strong>二叉搜索树</strong>。</p>
<p>因此可以设置row和col，从右上角开始，若当前val大于target，则向二叉树的左子树，即col&ndash;；若val小于target，则row++；否则返回。</p>
<p>需要注意可能有输入为空数组的情况。</p>
<h3 id="剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</h3>
<p>简单题做法是，直接遍历查找，时间复杂度是O(n)。</p>
<p>进阶做法，将时间复杂度降低为O(logN)。使用<strong>二分查找</strong>。</p>
<p>指针left、right分别指向头和尾，中间为mid。分以下情况，注意<strong>开闭区间</strong>：</p>
<ul>
<li>若mid大于right，说明最小值必在(mid,right]之间，因此取left=mid+1；</li>
<li>若mid小于right，说明最小值在[left, mid]之间，因此取right=mid；</li>
<li>若mid和right相等，则说明(mid, right]中间的值有重复的，需要去重，但无法确定中间是否会存在更小值，如[1,1,1,1,0,1,1,]，因此需要right&ndash;。</li>
</ul>
<p>为什么不和left比较呢？因为旋转数组的特征是，右边一定比左边小。若考虑与left比较：</p>
<ul>
<li>
<p>若mid小于left，说明最小值在(left, mid]之间；</p>
</li>
<li>
<p>若mid大于left，则说明左边是升序，但不能说明最小值位置，因为可能有[1,2,3,4,5]这类旋转长度为0的数组。</p>
</li>
</ul>
<p><strong>二分查找要点</strong>：二分查找有几种写法？它们的区别是什么？ - Jason Li的回答 - 知乎 <a href="https://www.zhihu.com/question/36132386/answer/530313852">https://www.zhihu.com/question/36132386/answer/530313852</a></p>
<h3 id="剑指-offer-50-第一个只出现一次的字符">剑指 Offer 50. 第一个只出现一次的字符</h3>
<p>使用哈希表，遍历两次。</p>
<h2 id="day-6-搜索与回溯算法-easy">Day 6. 搜索与回溯算法 (Easy)</h2>
<p>三题BFS</p>
<h3 id="剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</h3>
<p>二叉树的层序遍历，利用一个队列来实现。</p>
<p>需要注意可能有输入为空数组的情况。</p>
<h3 id="剑指-offer-32---ii-从上到下打印二叉树-ii">剑指 Offer 32 - II. 从上到下打印二叉树 II</h3>
<p>层序遍历BFS。与上题区别在于按层进行打印，分别保存到不同vector中。</p>
<p>核心思路是，当前遍历队列时，队列中只有这一层的节点。</p>
<p>个人做法是，使用一个临时的队列变量保存下一层的节点，当前层的队列为空时，遍历下一个队列，代码略微繁琐。</p>
<p>网上做法普遍是，在while的一次循环中，再加入一个for循环，次数为当前队列长度；之后下一层节点可以直接加入到队列中（因为当前层的遍历个数已经确定）。该种做法相对更节省空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> ans;
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> ans;
        queue<span style="color:#f92672">&lt;</span>TreeNode <span style="color:#f92672">*&gt;</span> points;
        points.push(root);
        <span style="color:#66d9ef">while</span>(points.size()){
            <span style="color:#66d9ef">int</span> col<span style="color:#f92672">=</span>points.size();
            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans1;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>col;i<span style="color:#f92672">++</span>){
                TreeNode <span style="color:#f92672">*</span>temp<span style="color:#f92672">=</span>points.front();
                points.pop();
                ans1.push_back(temp<span style="color:#f92672">-&gt;</span>val);
                <span style="color:#66d9ef">if</span>(temp<span style="color:#f92672">-&gt;</span>left) points.push(temp<span style="color:#f92672">-&gt;</span>left);
                <span style="color:#66d9ef">if</span>(temp<span style="color:#f92672">-&gt;</span>right) points.push(temp<span style="color:#f92672">-&gt;</span>right);
            }
            ans.push_back(ans1);
        }
        <span style="color:#66d9ef">return</span> ans;
    }
};
</code></pre></div><h3 id="剑指-offer-32---iii-从上到下打印二叉树-iii">剑指 Offer 32 - III. 从上到下打印二叉树 III</h3>
<p>再上一题基础上，判断每一层的层数，并进行reverse。</p>
<h2 id="day-7-搜索与回溯算法-easy">Day 7. 搜索与回溯算法 (Easy)</h2>
<h3 id="剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</h3>
<p>判断二叉树B是不是二叉树A的子结构，只需要判断三种情况：B是不是A的从根节点开始的子结构；B是不是<strong>A的左子树</strong>的从根节点开始的子结构；B是不是<strong>A的右子树</strong>的从根节点开始的子结构。</p>
<p>判断两个二叉树是否从根节点开始重合，使用DFS。<strong>需要注意，顺序上要先判断B的节点，为NULL时，说明已经相同，</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(TreeNode<span style="color:#f92672">*</span> a, TreeNode<span style="color:#f92672">*</span>b){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">==</span>b<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&amp;&amp;</span> dfs(a<span style="color:#f92672">-&gt;</span>left, b<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&amp;&amp;</span> dfs(a<span style="color:#f92672">-&gt;</span>right, b<span style="color:#f92672">-&gt;</span>right);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubStructure</span>(TreeNode<span style="color:#f92672">*</span> A, TreeNode<span style="color:#f92672">*</span> B) {
    <span style="color:#66d9ef">if</span>(A<span style="color:#f92672">==</span>NULL <span style="color:#f92672">||</span> B<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> dfs(A, B) <span style="color:#f92672">||</span> isSubStructure(A<span style="color:#f92672">-&gt;</span>left, B) <span style="color:#f92672">||</span> isSubStructure(A<span style="color:#f92672">-&gt;</span>right, B);
}
</code></pre></div><h3 id="剑指-offer-27-二叉树的镜像">剑指 Offer 27. 二叉树的镜像</h3>
<p>递归实现。</p>
<h3 id="剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</h3>
<p>首先想法是使用上一题的镜像，在判断原始二叉树和镜像二叉树是否相同。但显然这个方法比较繁琐。</p>
<p>回到对称二叉树本身性质：对于二叉树中任意<strong>两个对称节点</strong>，该节点的left和right值相同，且left的left与right的right相同，left的right与right的left相同，因此可以有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSymmetricSub</span>(TreeNode<span style="color:#f92672">*</span> leftNode, TreeNode<span style="color:#f92672">*</span> rightNode){
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>leftNode <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rightNode) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">if</span>((leftNode<span style="color:#f92672">&amp;&amp;</span>rightNode)<span style="color:#f92672">==</span>false <span style="color:#f92672">||</span> leftNode<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> rightNode<span style="color:#f92672">-&gt;</span>val) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> isSymmetricSub(leftNode<span style="color:#f92672">-&gt;</span>left, rightNode<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">&amp;&amp;</span> isSymmetricSub(leftNode<span style="color:#f92672">-&gt;</span>right, rightNode<span style="color:#f92672">-&gt;</span>left);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSymmetric</span>(TreeNode<span style="color:#f92672">*</span> root) {
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">return</span> isSymmetricSub(root<span style="color:#f92672">-&gt;</span>left, root<span style="color:#f92672">-&gt;</span>right);
}
</code></pre></div><h2 id="day-8-动态规划-easy">Day 8. 动态规划 (Easy)</h2>
<h3 id="剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</h3>
<h3 id="剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</h3>
<h3 id="剑指-offer-63-股票的最大利润">剑指 Offer 63. 股票的最大利润</h3>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/leetcode">LeetCode</a></li>
					
					<li><a href="/tags/%E5%89%91%E6%8C%87offer">剑指Offer</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://github.com/kian98" title="GitHub"><i data-feather="github"></i></a>|<a class="soc" href="mailto:kian09cn@hotmail.com" title="Mail"><i data-feather="mail"></i></a>|⚡️
	2021  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script></div>
    </body>
</html>
