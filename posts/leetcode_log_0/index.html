<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Leetcode-剑指Offer-Log-0 - bbbbbbb log</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="刷题刷题！" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Leetcode-剑指Offer-Log-0" />
<meta property="og:description" content="刷题刷题！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kian98.github.io/posts/leetcode_log_0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-27T16:53:00+08:00" />
<meta property="article:modified_time" content="2021-11-27T16:53:00+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode-剑指Offer-Log-0"/>
<meta name="twitter:description" content="刷题刷题！"/>
<script src="https://kian98.github.io/js/feather.min.js"></script>
	
	
        <link href="https://kian98.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://kian98.github.io/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://kian98.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://kian98.github.io/">bbbbbbb log</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Leetcode-剑指Offer-Log-0</h1>
			<div class="meta">Posted on Nov 27, 2021</div>
		</div>
		

		<section class="body">
			<h2 id="day-1-栈与队列--easy-">Day 1. 栈与队列 ( Easy )</h2>
<h3 id="剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</h3>
<p>栈的特点是后进后出，队列是先进后出。使用双栈相当于使用其中一个栈作为暂存的区域，来实现队列的功能。</p>
<h3 id="剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</h3>
<p>题目要求：实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>考虑栈后入先出的特点，解题思路是，在入栈时，每个元素添加一个额外属性：当前最小值。</p>
<h2 id="day-2-链表--easy-">Day 2. 链表 ( Easy )</h2>
<h3 id="剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</h3>
<p>两种思路：</p>
<p><strong>辅助栈</strong>。利用栈后进先出的特性，额外开辟一个栈暂存链表数据，出栈时即为逆序。</p>
<p><strong>递归</strong>。利用递归，先走到链表结尾，回溯时依次将值加入到队列中。</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> reversePrint(ListNode<span style="color:#f92672">*</span> head){
  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>head) <span style="color:#66d9ef">return</span> {};
  <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>val;
  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ret <span style="color:#f92672">=</span> reversePrint(head<span style="color:#f92672">-&gt;</span>next);
  ret.push_back(val);
  <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p><strong>粗暴法</strong>。顺序保存，用algorithm库直接reverse。</p>
<h3 id="剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</h3>
<p>数据结构入门题目。三种基本解法。</p>
<p><strong>迭代法</strong>。使用<strong>双指针</strong>。设置一个cur指针指示当前所在位置，一个pre指针指向前一个节点。</p>
<p>初始状态下，cur指向的是head节点，pre指向NULL。</p>
<p>迭代过程中，先暂存cur-&gt;next所指向的节点为temp，将cur-&gt;next指向pre，再将pre更新为cur，cur更新为temp，完成翻转。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">reverseList</span>(ListNode<span style="color:#f92672">*</span> head) {
  ListNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> NULL;
  ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> head;
  <span style="color:#66d9ef">while</span>(cur){
    ListNode<span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
    cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre;
    pre <span style="color:#f92672">=</span> cur;
    cur <span style="color:#f92672">=</span> next;
  }
  <span style="color:#66d9ef">return</span> pre;
}
</code></pre></div><p><strong>辅助栈法</strong>。先遍历链表，保存value到栈中，再依次出栈，重新为链表赋值。</p>
<p><strong>递归法</strong>。核心思想是，对于当前节点cur，将下一个节点cu r-&gt;next为头节点的链表进行翻转，然后将cur-&gt;next节点的next指针指向cur，完成翻转。</p>
<p>需要注意三个情况，（1）输入为NULL时，直接返回head（2）处理head节点时，head-&gt;next在反转后最后应该为NULL（3）最后需要返回反转后的新的头节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">reverseList</span>(ListNode<span style="color:#f92672">*</span> head) {
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>head <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>head<span style="color:#f92672">-&gt;</span>next ) <span style="color:#66d9ef">return</span> head;
    ListNode<span style="color:#f92672">*</span> newHead <span style="color:#f92672">=</span> reverseList(head<span style="color:#f92672">-&gt;</span>next);
    head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> newHead;
}
</code></pre></div><h3 id="剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</h3>
<p>该题关键在于如何记录原链表和新链表的节点对应关系。直观解法是使用哈希，即Map。</p>
<p><strong>哈希表法</strong>。空间复杂度为O(n)，时间复杂度为O(n)，遍历两遍原链表。</p>
<p><strong>原地复制</strong>。首先将每个节点复制一遍，添加到原有节点之后，如1-&gt;2-&gt;3-&gt;NULL复制为1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;NULL；从头开始遍历链表，将random指针指向对应节点或NULL；将链表拆分。该方法可以将空间复杂度降低为O(1)。</p>
<h2 id="day-3-字符串--easy-">Day 3. 字符串 ( Easy )</h2>
<h3 id="剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</h3>
<p>使用string API操作，可以使用find、erase、insert原地操作；也可以遍历操作，新建字符串，使用append。</p>
<p>一定要用时间复杂度为O(n)。</p>
<p>可以使用双指针，用vector。</p>
<p>可以使用array数组，第一遍遍历确定空格数量，确定新数组的长度，第二遍遍历就可以直接复制给新数组。</p>
<p>从前往后遍历替换会导致元素被覆盖，则<strong>可以考虑从后往前遍历。</strong></p>
<h3 id="剑指-offer-58---ii-左旋转字符串">剑指 Offer 58 - II. 左旋转字符串</h3>
<p>使用string API操作，则使用substr获取子串。</p>
<p><strong>原地反转</strong>。思路是先反转n以前的子串，再反转n以后的子串，最后反转整个子串，可以得到一个拼接后的子串。问题化简为三个字符串反转问题。</p>
<p>原地字符串反转，使用双指针解法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> reverseString(string <span style="color:#f92672">&amp;</span>s, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j){
        <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">&lt;</span> j){
            s[i] <span style="color:#f92672">^=</span> s[j];
            s[j] <span style="color:#f92672">^=</span> s[i];
            s[i] <span style="color:#f92672">^=</span> s[j];
            i<span style="color:#f92672">++</span>;j<span style="color:#f92672">--</span>;
        }
    }
    string <span style="color:#a6e22e">reverseLeftWords</span>(string s, <span style="color:#66d9ef">int</span> n) {
        reverseString(s, <span style="color:#ae81ff">0</span>, n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        reverseString(s, n, s.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        reverseString(s, <span style="color:#ae81ff">0</span>, s.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">return</span> s;
    }
};
</code></pre></div><h2 id="day-4-查找算法---easy-">Day 4. 查找算法  ( Easy )</h2>
<h3 id="剑指-offer-03-数组中重复的数字">剑指 Offer 03. 数组中重复的数字</h3>
<p>最直接思路是利用<strong>哈希表</strong>，C++中使用map。时间复杂度O(n)，空间复杂度也为O(n)。</p>
<p><strong>排序后遍历</strong>。先原地排序（如堆排序），若相邻元素相同，则return。</p>
<p><strong>原地交换</strong>。题干中指明，所有数字都在 0～n-1 的范围内，数组索引和值是一对多的关系，因此可以通过交换值，使得数组的索引和值达到对应。即</p>
<p>若nums[i] = i，则继续下一个i；</p>
<p>若nums[i] = nums[nums[i]]，说明有两个索引指向同一个值，找到该值；</p>
<p>否则交换nums[i]和nums[nums[i]]的值，这一步的最终必然可以将值换到与索引匹配的位置，或者找到重复值。</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)。</p>
<h3 id="剑指-offer-53---i-在排序数组中查找数字-i">剑指 Offer 53 - I. 在排序数组中查找数字 I</h3>
<p>在有序数组中查找数字出现次数，明显可以用<strong>二分查找法</strong>。</p>
<p>可以通过二分查找找到第一个出现的数字，也可以直接使用二分查找确定左右范围。</p>
<h3 id="剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</h3>
<p>同样使用<strong>二分查找</strong>。需要注意，二分查找要点在于边界值判断、循环条件判断，并且两者需要匹配。例如，left和right值如果存在不更新，直接等于mid的情况，那么while条件需要设置为不包括left=right。</p>
<h2 id="day-5-查找算法-medium">Day 5. 查找算法 (Medium)</h2>
<h3 id="-剑指-offer-04-二维数组中的查找">⭐️ 剑指 Offer 04. 二维数组中的查找</h3>
<p>一开始以为要用二分查找，但发现并不适用，并且会超时。</p>
<p>参考评论后，可以从矩阵右上角开始看，可以发现矩阵分布规律，类似一个<strong>二叉搜索树</strong>。</p>
<p>因此可以设置row和col，从右上角开始，若当前val大于target，则向二叉树的左子树，即col&ndash;；若val小于target，则row++；否则返回。</p>
<p>需要注意可能有输入为空数组的情况。</p>
<h3 id="剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</h3>
<p>简单题做法是，直接遍历查找，时间复杂度是O(n)。</p>
<p>进阶做法，将时间复杂度降低为O(logN)。使用<strong>二分查找</strong>。</p>
<p>指针left、right分别指向头和尾，中间为mid。分以下情况，注意<strong>开闭区间</strong>：</p>
<ul>
<li>若mid大于right，说明最小值必在(mid,right]之间，因此取left=mid+1；</li>
<li>若mid小于right，说明最小值在[left, mid]之间，因此取right=mid；</li>
<li>若mid和right相等，则说明(mid, right]中间的值有重复的，需要去重，但无法确定中间是否会存在更小值，如[1,1,1,1,0,1,1,]，因此需要right&ndash;。</li>
</ul>
<p>为什么不和left比较呢？因为旋转数组的特征是，右边一定比左边小。若考虑与left比较：</p>
<ul>
<li>
<p>若mid小于left，说明最小值在(left, mid]之间；</p>
</li>
<li>
<p>若mid大于left，则说明左边是升序，但不能说明最小值位置，因为可能有[1,2,3,4,5]这类旋转长度为0的数组。</p>
</li>
</ul>
<p><strong>二分查找要点</strong>：二分查找有几种写法？它们的区别是什么？ - Jason Li的回答 - 知乎 <a href="https://www.zhihu.com/question/36132386/answer/530313852">https://www.zhihu.com/question/36132386/answer/530313852</a></p>
<h3 id="剑指-offer-50-第一个只出现一次的字符">剑指 Offer 50. 第一个只出现一次的字符</h3>
<p>使用哈希表，遍历两次。</p>
<h2 id="day-6-搜索与回溯算法-easy">Day 6. 搜索与回溯算法 (Easy)</h2>
<p>三题BFS</p>
<h3 id="剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</h3>
<p>二叉树的层序遍历，利用一个队列来实现。</p>
<p>需要注意可能有输入为空数组的情况。</p>
<h3 id="剑指-offer-32---ii-从上到下打印二叉树-ii">剑指 Offer 32 - II. 从上到下打印二叉树 II</h3>
<p>层序遍历BFS。与上题区别在于按层进行打印，分别保存到不同vector中。</p>
<p>核心思路是，当前遍历队列时，队列中只有这一层的节点。</p>
<p>个人做法是，使用一个临时的队列变量保存下一层的节点，当前层的队列为空时，遍历下一个队列，代码略微繁琐。</p>
<p>网上做法普遍是，在while的一次循环中，再加入一个for循环，次数为当前队列长度；之后下一层节点可以直接加入到队列中（因为当前层的遍历个数已经确定）。该种做法相对更节省空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> ans;
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> ans;
        queue<span style="color:#f92672">&lt;</span>TreeNode <span style="color:#f92672">*&gt;</span> points;
        points.push(root);
        <span style="color:#66d9ef">while</span>(points.size()){
            <span style="color:#66d9ef">int</span> col<span style="color:#f92672">=</span>points.size();
            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans1;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>col;i<span style="color:#f92672">++</span>){
                TreeNode <span style="color:#f92672">*</span>temp<span style="color:#f92672">=</span>points.front();
                points.pop();
                ans1.push_back(temp<span style="color:#f92672">-&gt;</span>val);
                <span style="color:#66d9ef">if</span>(temp<span style="color:#f92672">-&gt;</span>left) points.push(temp<span style="color:#f92672">-&gt;</span>left);
                <span style="color:#66d9ef">if</span>(temp<span style="color:#f92672">-&gt;</span>right) points.push(temp<span style="color:#f92672">-&gt;</span>right);
            }
            ans.push_back(ans1);
        }
        <span style="color:#66d9ef">return</span> ans;
    }
};
</code></pre></div><h3 id="剑指-offer-32---iii-从上到下打印二叉树-iii">剑指 Offer 32 - III. 从上到下打印二叉树 III</h3>
<p>再上一题基础上，判断每一层的层数，并进行reverse。</p>
<h2 id="day-7-搜索与回溯算法-easy">Day 7. 搜索与回溯算法 (Easy)</h2>
<h3 id="剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</h3>
<p>判断二叉树B是不是二叉树A的子结构，只需要判断三种情况：B是不是A的从根节点开始的子结构；B是不是<strong>A的左子树</strong>的从根节点开始的子结构；B是不是<strong>A的右子树</strong>的从根节点开始的子结构。</p>
<p>判断两个二叉树是否从根节点开始重合，使用DFS。<strong>需要注意，顺序上要先判断B的节点，为NULL时，说明已经相同，</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(TreeNode<span style="color:#f92672">*</span> a, TreeNode<span style="color:#f92672">*</span>b){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">==</span>b<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&amp;&amp;</span> dfs(a<span style="color:#f92672">-&gt;</span>left, b<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&amp;&amp;</span> dfs(a<span style="color:#f92672">-&gt;</span>right, b<span style="color:#f92672">-&gt;</span>right);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubStructure</span>(TreeNode<span style="color:#f92672">*</span> A, TreeNode<span style="color:#f92672">*</span> B) {
    <span style="color:#66d9ef">if</span>(A<span style="color:#f92672">==</span>NULL <span style="color:#f92672">||</span> B<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> dfs(A, B) <span style="color:#f92672">||</span> isSubStructure(A<span style="color:#f92672">-&gt;</span>left, B) <span style="color:#f92672">||</span> isSubStructure(A<span style="color:#f92672">-&gt;</span>right, B);
}
</code></pre></div><h3 id="剑指-offer-27-二叉树的镜像">剑指 Offer 27. 二叉树的镜像</h3>
<p>递归实现。</p>
<h3 id="剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</h3>
<p>首先想法是使用上一题的镜像，在判断原始二叉树和镜像二叉树是否相同。但显然这个方法比较繁琐。</p>
<p>回到对称二叉树本身性质：对于二叉树中任意<strong>两个对称节点</strong>，该节点的left和right值相同，且left的left与right的right相同，left的right与right的left相同，因此可以有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSymmetricSub</span>(TreeNode<span style="color:#f92672">*</span> leftNode, TreeNode<span style="color:#f92672">*</span> rightNode){
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>leftNode <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rightNode) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">if</span>((leftNode<span style="color:#f92672">&amp;&amp;</span>rightNode)<span style="color:#f92672">==</span>false <span style="color:#f92672">||</span> leftNode<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> rightNode<span style="color:#f92672">-&gt;</span>val) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> isSymmetricSub(leftNode<span style="color:#f92672">-&gt;</span>left, rightNode<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">&amp;&amp;</span> isSymmetricSub(leftNode<span style="color:#f92672">-&gt;</span>right, rightNode<span style="color:#f92672">-&gt;</span>left);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSymmetric</span>(TreeNode<span style="color:#f92672">*</span> root) {
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">return</span> isSymmetricSub(root<span style="color:#f92672">-&gt;</span>left, root<span style="color:#f92672">-&gt;</span>right);
}
</code></pre></div><h2 id="day-8-动态规划-easy">Day 8. 动态规划 (Easy)</h2>
<h3 id="剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</h3>
<p>入门题。使用DP或者备忘录的递归。</p>
<h3 id="剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</h3>
<p>与上一题类似。</p>
<h3 id="剑指-offer-63-股票的最大利润">剑指 Offer 63. 股票的最大利润</h3>
<p>动态规划：</p>
<ul>
<li>状态定义：设动态规划列表为<em>dp</em>，<em>dp</em>[i]为前<em>i</em>天的最大利润；</li>
<li>转移方程：前<em>i</em>日最大利润=max(前(<em>i</em>−1)日最大利润,第<em>i</em>日价格−前<em>i</em>日最低价格)</li>
<li>初始状态：<em>dp</em>[0]=0</li>
<li>返回值：<em>dp</em>[n-1]最后一天利益</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxProfit</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
    <span style="color:#66d9ef">int</span> maxp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">int</span> minPrice <span style="color:#f92672">=</span> INT_MAX;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> iter<span style="color:#f92672">=</span>prices.begin();iter<span style="color:#f92672">!=</span>prices.end();iter<span style="color:#f92672">++</span>){
        minPrice <span style="color:#f92672">=</span> min(minPrice, <span style="color:#f92672">*</span>iter);
        maxp <span style="color:#f92672">=</span> max(maxp, <span style="color:#f92672">*</span>iter <span style="color:#f92672">-</span> minPrice);
    }
    <span style="color:#66d9ef">return</span> maxp<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span>maxp:<span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="day-8-动态规划-medium">Day 8. 动态规划 (Medium)</h2>
<p>动态规划方法 <a href="https://labuladong.gitee.io/algo/1/3/">https://labuladong.gitee.io/algo/1/3/</a></p>
<h3 id="-剑指-offer-42-连续子数组的最大和">⭐️ 剑指 Offer 42. 连续子数组的最大和</h3>
<p>从暴力计算到动态规划。</p>
<p><strong>暴力计算：</strong></p>
<ul>
<li>
<p>计算每一个sum(i, j)，时间复杂度为O(n^3)（i、j遍历所有，求和遍历i到j）；</p>
</li>
<li>
<p>也可以将sum(i, j)转化为sum(i, j-1)+value_j，时间复杂度为O(n^2)（i遍历所有，j遍历从i到结尾，记录最大值）；</p>
</li>
</ul>
<p><strong>动态规划：</strong></p>
<p>如果要以O(n)复杂度解决问题，那么就要在一次遍历过程中，得到<strong>以当前元素为结尾的所有数组的最大值dp[i]</strong>，在此基础上，获得<strong>所有这些最大值的最大值maxValue</strong>。</p>
<p>而在计算以A元素为起始，以B元素为结尾的数组和后，在计算以B+1元素为结尾的数组和时，只需要在前一个数组和的基础上，加上B+1元素，而前一个数组和（A起始，B结束）必然是小于dp[i]的，因此</p>
<ul>
<li><strong>dp[i] = max(nums[i], nums[i]+dp[i-1])</strong></li>
<li><strong>maxValue = max(maxValue, dp[i])</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubArray</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> dp <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>){
        dp <span style="color:#f92672">=</span> max(dp<span style="color:#f92672">+</span>nums[i], nums[i]);
        maxValue <span style="color:#f92672">=</span> max(dp, maxValue);
    }
    <span style="color:#66d9ef">return</span> maxValue;
}
</code></pre></div><h3 id="剑指-offer-47-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</h3>
<p>动态规划：</p>
<p>将到达每格的礼物最大价值记录为dp table。到达每一个格时，当前格的最大价值=max(左边格子的最大价值, 上边格子的最大价值)，因此遍历每一个格子即可，因为没有负值，因此最后取右下角格子的值。需要注意边界的行和列。时间复杂度为O(MN)。</p>
<p>进一步优化，可以将dp table直接保存在输入的二维数组中。空间复杂度为O(1)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxValue</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
    <span style="color:#66d9ef">if</span>(grid.size()<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> row<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;row <span style="color:#f92672">&lt;</span> grid.size(); row<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;col <span style="color:#f92672">&lt;</span> grid[<span style="color:#ae81ff">0</span>].size(); col<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">if</span>(row<span style="color:#f92672">+</span>col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>; 
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (row <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) grid[row][col] <span style="color:#f92672">+=</span> grid[row][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(col <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) grid[row][col] <span style="color:#f92672">+=</span> grid[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col];
            <span style="color:#66d9ef">else</span> grid[row][col] <span style="color:#f92672">+=</span> max(grid[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col], grid[row][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
        }
    }
    <span style="color:#66d9ef">return</span> grid[grid.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][grid[<span style="color:#ae81ff">0</span>].size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>可以进一步优化，当M、N较大时，遍历过程中的if判断语句仍然耗时，因此可以将对边界的判断移出来单独计算，两层循环从1开始。</p>
<h2 id="day-9-动态规划--medium">Day 9. 动态规划  (Medium)</h2>
<h3 id="剑指-offer-46-把数字翻译成字符串">剑指 Offer 46. 把数字翻译成字符串</h3>
<p>关键在于，第一位到第n位的数字的翻译方法的数量，取决于前两位是否可以被翻译，即</p>
<p>dp[i] = dp[i-1] + (dp[i-2:i]可以被翻译) ? 1 : 0;</p>
<p>而如何取出第i位的前两位，可以使用取余的方法。</p>
<p>这一题从左往右和从右往左处理是一样的。</p>
<h3 id="剑指-offer-48-最长不含重复字符的子字符串">剑指 Offer 48. 最长不含重复字符的子字符串</h3>
<p>如果暴力求解，长度为N的字符串，计算所有子字符串，复杂度为O(N^2)，而判断当前字符是否在子串中，复杂度为O(N)，因此暴力的复杂度为O(N^3)。</p>
<p><strong>动态规划：</strong></p>
<p>用DP的思想求解，核心在于，要记录<strong>当前字符为结尾的最大不重复子串</strong>的值。</p>
<p>则可以得到状态转移方程：</p>
<ul>
<li>若当前字符s[i]前一次出现位置，不在前一个字符的最大子串范围内，则dp[j] = dp[j-1] + 1；</li>
<li>否则，dp[j] = j - i，i为该字符上一次出现的位置。</li>
</ul>
<p>由于要判断字符在子串中的位置，直接的思路是利用string的find_last_of函数，但复杂度高，因此可以使用哈希表记录，进一步，可以用数组替换Map，提高速度。字符的ASCII范围在0～127，因此可以用128维数组表示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(string s) {
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> charMap;
    <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> lastLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> charMap.find(s[i]);
        <span style="color:#66d9ef">int</span> curLen <span style="color:#f92672">=</span> (iter<span style="color:#f92672">==</span>charMap.end()) <span style="color:#f92672">?</span> lastLen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> min(i <span style="color:#f92672">-</span> iter<span style="color:#f92672">-&gt;</span>second, lastLen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
        charMap[s[i]] <span style="color:#f92672">=</span> i;
        lastLen <span style="color:#f92672">=</span> curLen;
        maxLen <span style="color:#f92672">=</span> max(curLen, maxLen);
    }
    <span style="color:#66d9ef">return</span> maxLen;
}
</code></pre></div><p>动态规划的思路可以从暴力方法逐步优化得到。</p>
<p><strong>滑动窗口：</strong></p>
<p>这一题用滑动窗口的方法更为合适，本质思路与DP相同。DP方法记录的是子串（长度），而滑动窗口记录的是子串起始位置。</p>
<p>需要注意，字符左起始位置初始值的设置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(string s) {
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> charMap;
    <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> lastBeg <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> charMap.find(s[i]);
        <span style="color:#66d9ef">int</span> curBeg <span style="color:#f92672">=</span> (iter<span style="color:#f92672">==</span>charMap.end()) <span style="color:#f92672">?</span> lastBeg : max(lastBeg, iter<span style="color:#f92672">-&gt;</span>second);
        charMap[s[i]] <span style="color:#f92672">=</span> i;
        lastBeg <span style="color:#f92672">=</span> curBeg;
        maxLen <span style="color:#f92672">=</span> max(maxLen, i <span style="color:#f92672">-</span> curBeg);
    }
    <span style="color:#66d9ef">return</span> maxLen;
}
</code></pre></div><h2 id="day-11-双指针-easy">Day 11. 双指针 (Easy)</h2>
<h3 id="剑指-offer-18-删除链表的节点">剑指 Offer 18. 删除链表的节点</h3>
<p>设置pre和cur双指针。</p>
<p>需要注意删除头节点的特例。</p>
<h3 id="剑指-offer-22-链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点</h3>
<p>设置快慢指针，快指针移动k-1步后，慢指针开始移动。</p>
<p>需要注意题目是否提及特例，如：k可能为0；k可能超过链表长度；head可能为NULL等。</p>
<h2 id="day-12-双指针-easy">Day 12. 双指针 (Easy)</h2>
<h3 id="剑指-offer-25-合并两个排序的链表">剑指 Offer 25. 合并两个排序的链表</h3>
<p>使用双指针很容易完成。每次取链表中的较小值，当其中一个链表遍历结束，直接与另一链表剩余部分拼接。</p>
<p>小trick在于构造一个伪头节点，可以涵盖两个链表起始位置以及出现NULL的情况。</p>
<p>也可以使用递归做法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeTwoLists</span>(ListNode<span style="color:#f92672">*</span> l1, ListNode<span style="color:#f92672">*</span> l2) {
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>l1) <span style="color:#66d9ef">return</span> l2;
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>l2) <span style="color:#66d9ef">return</span> l1;
    ListNode<span style="color:#f92672">*</span> ret;
    <span style="color:#66d9ef">if</span>(l1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">-&gt;</span>val){
        ret <span style="color:#f92672">=</span> l1;
        ret<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeTwoLists(l1<span style="color:#f92672">-&gt;</span>next, l2);
    }<span style="color:#66d9ef">else</span>{
        ret <span style="color:#f92672">=</span> l2;
        ret<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeTwoLists(l1, l2<span style="color:#f92672">-&gt;</span>next);
    }
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><h3 id="剑指-offer-52-两个链表的第一个公共节点">剑指 Offer 52. 两个链表的第一个公共节点</h3>
<p>暴力解法，使用哈希表。先遍历并记录链表A，再遍历和查询链表B的元素。时间复杂度为O(M+N)，空间复杂度为O(M)。</p>
<p><strong>双指针法</strong>。降低空间复杂度至O(1)。</p>
<p>创建两个指针，分别指向两个链表的头节点，同时开始遍历。当指针遇到链表结尾时，继续从另一个链表头开始遍历，直至两个指针相同。</p>
<p>分情况证明正确性：</p>
<ul>
<li>当两链表相交时，若相交前长度一致，则会在相交的地方停止遍历，若不一致，则会在遍历两链表m+n的长度后停止。</li>
<li>若两链表不相交，则会停止在链表的尾部NULL（若相同长度则各自停止，若不同则停在另一个链表）。</li>
</ul>
<p>可以考虑链表为空的情况。</p>
<h2 id="day-13-双指针-easy">Day 13. 双指针 (Easy)</h2>
<h3 id="剑指-offer-21-调整数组顺序使奇数位于偶数前面">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3>
<p>**首尾双指针。**left指针向右移动，right指针向左移动，当left指向偶数切right指向奇数，则swap；</p>
<p>**快慢双指针。**fast用于查找要调换位置的奇数，slow指向奇数要放的位置，因为进行swap时，fast指向的是奇数，slow前的全是奇数，slow和fast之间的，全部是偶数（因为fast已经经过，所以都被调换到slow前）。</p>
<h3 id="剑指-offer-57-和为s的两个数字">剑指 Offer 57. 和为s的两个数字</h3>
<p>若数组为无序，可以使用<strong>hashmap</strong>的思路，记录已有的数字，每次判断是否已存在对应的另一个数字。</p>
<p>本题为有序数组，因此可以用双指针法。设置前后指针，两边往中间找。</p>
<h3 id="剑指-offer-58---i-翻转单词顺序">剑指 Offer 58 - I. 翻转单词顺序</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">string <span style="color:#a6e22e">reverseWords</span>(string s) {
    string ret <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
    <span style="color:#66d9ef">int</span> beg <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    s <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; &#34;</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>s.size();i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>){
            <span style="color:#66d9ef">if</span>(beg<span style="color:#f92672">!=</span>i) ret <span style="color:#f92672">=</span> s.substr(beg, i<span style="color:#f92672">-</span>beg) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> ret;
            beg <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">if</span>(ret.size()<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>)ret.pop_back();
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><h2 id="day-14-搜索与回溯算法-medium">Day .14 搜索与回溯算法 (Medium)</h2>
<h3 id="剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</h3>
<p>矩阵搜索题，使用DFS+剪枝。</p>
<p>DFS的思路比较容易想，但剪枝的处理会略微复杂。在矩阵中搜索，需要考虑上、下、左、右四个方向，同时要考虑矩阵边界和已经经过的位置。</p>
<p>在本题中，保存经过的位置，可以使用'\0&rsquo;替换走过的路径，在进入四个方向的遍历前，置为'\0'，返回后恢复原值，以此节省存储空间。</p>
<p>此外，由于字符串的开头可能是任意一个位置，因此还需要对矩阵每个位置进行遍历。</p>
<p>对于M*N的矩阵，字符串长度为K，对矩阵每个位置进行K次递归，时间复杂度为$O(3^K<em>M</em>N) $；递归深度不超过K，空间复杂度为$O(K)$。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> exist(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board, string word) {
        rows <span style="color:#f92672">=</span> board.size();
        cols <span style="color:#f92672">=</span> board[<span style="color:#ae81ff">0</span>].size();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> rows; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> cols; j<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">if</span>(dfs(board, word, i, j, <span style="color:#ae81ff">0</span>)) <span style="color:#66d9ef">return</span> true;
            }
        }
        <span style="color:#66d9ef">return</span> false;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> rows, cols;
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board, string word, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j, <span style="color:#66d9ef">int</span> k) {
        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;=</span> rows <span style="color:#f92672">||</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;=</span> cols <span style="color:#f92672">||</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> board[i][j] <span style="color:#f92672">!=</span> word[k]) <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">if</span>(k <span style="color:#f92672">==</span> word.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> true;
        board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
        <span style="color:#66d9ef">bool</span> res <span style="color:#f92672">=</span> dfs(board, word, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j, k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> dfs(board, word, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j, k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> 
                      dfs(board, word, i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> dfs(board, word, i , j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
        board[i][j] <span style="color:#f92672">=</span> word[k];
        <span style="color:#66d9ef">return</span> res;
    }
};
</code></pre></div><h3 id="剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</h3>
<p><strong>DFS+剪枝</strong></p>
<p>解题思路与上一题相同。在本题中，可以只考虑向下和向右的移动。</p>
<p><strong>BFS</strong></p>
<p>也可以借助队列，使用BFS</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> movingCount(<span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k) {
        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> visited(m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">0</span>));
        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        queue<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> que;
        que.push({ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> });
        <span style="color:#66d9ef">while</span>(que.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> x <span style="color:#f92672">=</span> que.front();
            que.pop();
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> x[<span style="color:#ae81ff">0</span>], j <span style="color:#f92672">=</span> x[<span style="color:#ae81ff">1</span>], si <span style="color:#f92672">=</span> x[<span style="color:#ae81ff">2</span>], sj <span style="color:#f92672">=</span> x[<span style="color:#ae81ff">3</span>];
            <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> k <span style="color:#f92672">&lt;</span> si <span style="color:#f92672">+</span> sj <span style="color:#f92672">||</span> visited[i][j]) <span style="color:#66d9ef">continue</span>;
            visited[i][j] <span style="color:#f92672">=</span> true;
            res<span style="color:#f92672">++</span>;
            que.push({ i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j, (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> si <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> si <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span>, sj });
            que.push({ i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, si, (j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> sj <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> sj <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span> });
        }
        <span style="color:#66d9ef">return</span> res;
    }
};
</code></pre></div><h2 id="day-15-搜索与回溯算法-medium">Day 15. 搜索与回溯算法 (Medium)</h2>
<h3 id="剑指-offer-34-二叉树中和为某一值的路径">剑指 Offer 34. 二叉树中和为某一值的路径</h3>
<p>二叉树搜索，使用回溯法，思想和DFS相同：</p>
<p>判断边界-&gt;判断成立条件-&gt;进行下一轮遍历。</p>
<p>这一题需要注意的是，如何保存每一种路径，使用的方法是每进入一个新的递归，为路径path加入节点，退出时删去这个节点；若路径可用，则将路径加入到最终返回的vector中。</p>
<p>本题也可以使用BFS，但实现上更复杂，不推荐。</p>
<h3 id="剑指-offer-36-二叉搜索树与双向链表">剑指 Offer 36. 二叉搜索树与双向链表</h3>
<p>将二叉搜索树转化为一个递增的双向链表，结合二叉搜索树的性质，使用中序遍历即可，将每个遍历到的节点加入到双向链表中，最后将双向链表的尾节点和头节点相连。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Node<span style="color:#f92672">*</span> treeToDoublyList(Node<span style="color:#f92672">*</span> root) {
        <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
        dfs(root);
        head<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> pre;
        pre<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> head;
        <span style="color:#66d9ef">return</span> head;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    Node <span style="color:#f92672">*</span>pre, <span style="color:#f92672">*</span>head;
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(Node<span style="color:#f92672">*</span> cur) {
        <span style="color:#66d9ef">if</span>(cur <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span>;
        dfs(cur<span style="color:#f92672">-&gt;</span>left);
        <span style="color:#66d9ef">if</span>(pre <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) pre<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> cur;
        <span style="color:#66d9ef">else</span> head <span style="color:#f92672">=</span> cur;
        cur<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> pre;
        pre <span style="color:#f92672">=</span> cur;
        dfs(cur<span style="color:#f92672">-&gt;</span>right);
    }
};
</code></pre></div><h3 id="剑指-offer-54-二叉搜索树的第k大节点">剑指 Offer 54. 二叉搜索树的第k大节点</h3>
<p>二叉搜索树的特性是，左子树所有节点的值小于根节点，右子树所有节点的值大于根节点。其中序遍历（左、根、右）得到的是从小到大的递增序列。</p>
<p>因此可以使用中序遍历的逆序，并且判断到达k个节点后提前返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> kmax;
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder_reverse</span>(TreeNode<span style="color:#f92672">*</span> node, <span style="color:#66d9ef">int</span> k){
        <span style="color:#66d9ef">if</span>(kmax.size() <span style="color:#f92672">&gt;</span> k <span style="color:#f92672">||</span> node<span style="color:#f92672">==</span><span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span>;
        inorder_reverse(node<span style="color:#f92672">-&gt;</span>right, k);
        kmax.emplace_back(node<span style="color:#f92672">-&gt;</span>val);
        inorder_reverse(node<span style="color:#f92672">-&gt;</span>left, k);
    }

    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kthLargest</span>(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> k) {
        inorder_reverse(root, k);
        <span style="color:#66d9ef">return</span> kmax[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    }
};
</code></pre></div><h2 id="day-16-排序-easy">Day 16. 排序 (Easy)</h2>
<h3 id="剑指-offer-45-把数组排成最小的数">⭐️剑指 Offer 45. 把数组排成最小的数</h3>
<p>求拼接后的最小数字，本质是排序问题。</p>
<p>两个数字的字符串x和y，排序规则为</p>
<ul>
<li>x+y&gt;y+x，则x &gt; y</li>
<li>x+y&lt;y+x，则x &lt; y</li>
</ul>
<p>C++中字符串的字典序排序直接用&gt;、&lt;符号即可。</p>
<p>具体排序的方法，可以选择：</p>
<p>1、自己实现。则本题转化为排序算法的实现。根据时间和内存限制选择最佳算法。</p>
<p>2、使用内置sort函数，并重载compare函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">compare</span>(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>a,<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>b)
{
  <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b<span style="color:#f92672">&lt;</span>b<span style="color:#f92672">+</span>a;
}
<span style="color:#75715e">//////////
</span><span style="color:#75715e">// or
</span><span style="color:#75715e">/////////
</span><span style="color:#75715e"></span>sort(strs.begin(), strs.end(), [](string<span style="color:#f92672">&amp;</span> x, string<span style="color:#f92672">&amp;</span> y){ <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y <span style="color:#f92672">&lt;</span> y <span style="color:#f92672">+</span> x; });

</code></pre></div><p><strong>快排模板</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Paritition1(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
  <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> A[low];
  <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high) {
    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> A[high] <span style="color:#f92672">&gt;=</span> pivot) {
      <span style="color:#f92672">--</span>high;
    }
    A[low] <span style="color:#f92672">=</span> A[high];
    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> A[low] <span style="color:#f92672">&lt;=</span> pivot) {
      <span style="color:#f92672">++</span>low;
    }
    A[high] <span style="color:#f92672">=</span> A[low];
  }
  A[low] <span style="color:#f92672">=</span> pivot;
  <span style="color:#66d9ef">return</span> low;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) <span style="color:#75715e">//快排母函数
</span><span style="color:#75715e"></span>{
  <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> Paritition1(A, low, high);
    QuickSort(A, low, pivot <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    QuickSort(A, pivot <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
  }
}
</code></pre></div><h3 id="剑指-offer-61-扑克牌中的顺子">剑指 Offer 61. 扑克牌中的顺子</h3>
<p>自己的方法：</p>
<p>设置辅助数组，将五张牌记录下来，存在则置1；同时记录0的个数。</p>
<p>找到数组中非零的最小值，则从该数往后五个位置中，为1的数的个数+之前记录的0的个数=5，则说明为顺子。</p>
<p>题解方法：</p>
<p>五张牌为顺子的充分条件：</p>
<ul>
<li>除大小王外，所有牌无重复；（若有重复，必然不能五张为顺子）</li>
<li>除大小王外，最大牌-最小牌&lt;5；（若大于等于5，即使有王，也无法连续）</li>
</ul>
<p>因此遍历一次获取最大值、最小值、是否重复即可。</p>
<h2 id="day-17-排序-medium">Day 17. 排序 (Medium)</h2>
<h3 id="剑指-offer-40-最小的k个数">剑指 Offer 40. 最小的k个数</h3>
<p>考察排序算法。</p>
<p><strong>TODO: 实现多种算法</strong></p>
<h3 id="剑指-offer-41-数据流中的中位数">剑指 Offer 41. 数据流中的中位数</h3>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/leetcode">LeetCode</a></li>
					
					<li><a href="/tags/%E5%89%91%E6%8C%87offer">剑指Offer</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://github.com/kian98" title="GitHub"><i data-feather="github"></i></a>|<a class="soc" href="mailto:kian09cn@hotmail.com" title="Mail"><i data-feather="mail"></i></a>|⚡️
	2021  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script></div>
    </body>
</html>
